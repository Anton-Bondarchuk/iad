

Приветствую коллеги сегодня мы поговорим на довольно хайповую наверное тему и супер широкую о том какие способы работы с ошибками есть и потом пытаемся найти закономерности и сделать некоторые регламенты супер слайды работают план нашего путешествия мы пробежимся по базовым понятиям Потом посмотрим на способы работы ошибки выделим те из которых которые нам дают Что произошло потом где и когда произошла ошибка научимся Дод данные чтобы воспроизводить ошибки и потом рассмотрим другие способы как ещё можно обработать ошибки ивыведем всё это в регламент на протяжении нашего доклада вы будете видеть Легенду я выделил условно три чаще всего встречающихся вида приложения которые пишутся на Go плюс внизу вы видите QR код на презентацию чтобы если что Легенда была всегда перед глазами далее над каждым значком А по будет появляться например вопросительный знак значит способ обработки можно применять но есть э определённые условия а далее если видим крестик над программным обеспечением значит не используем этот вариант ошибки обработки ошибки и эпопытаемся сейчас прочитать всю Легенду одновременно У нас есть библиотека в ней мы можем применять Этот способ обработки А есть колай интерфейсы там можно применять но есть ограничения Ну и в сервисах мы не применяем и теперь давайте перейдём к базе Я думаю все знают что ошибки в не бывают я выделяю условно три вида ошибки это необрабатываемое которые создаются через Error New senal eror и Custom Error и Давайте подробно поговорим о каждом из Эх типов А первый необрабатываемое их свойства то что мы их не можемпрограммно отловить через eror is или eror S Да мы можем попытаться использовать contains либо regex но это не надёжный способ и он может нам дать отлавливает билем ошибки чаще всего является Не программа а конечный пользователь который будет именно считывать текст следующий вариант обработки ошибок - это они уже лишены этого недостатка они могут быть обработаны програмно создаются во время запуска программы в виде чаще всего глобальных переменных и обрабатывается через програм и имеют Style Guide а то что вначале мы прописываем им префикс Y но у eror senal есть недостаток что у них не динамических данных в ошибке Да можно добавить через wrapping либо использовать Custom errors А в которое мы как раз э задаём в виде отдельной структуры и доки туда данные и в динамике можем туда их положить и потом вывести а customer errors также легко обрабатывается программно через Error S и имеет простой Style Guide что мы в конце дописывая Error и применяется также во всех видах приложения а но дополнительно у customererrors можно докинути её но стоит сразу учитывать что это поведение должно быть контекст Независимо что я имею в виду а предположим У нас есть разрешение днса А и одна программа например хост если она получит ошибку о том что не смогла это сделать то она сразу упадёт и это будет для неё а не временная ошибка А в случае с курлов делать пере запросы и в таком случае ошибка является временной и если вы добавляете методы в customer euros то учитывайте что этот метод который описывает ошибку должен считыватьсяпри всё время одинаковым образом независимо от контекста а далее что у нас есть в базе это вранг вранг - это супер мощный инструмент используется везде может нам позволить накинуть дополнительные сообщение в нашу ошибку снить несколько ошибок в одну докинути к ним к таким случаям можно отнести Когда у нас значение по умолчанию не валидно то есть мы хотим например отлавливать порты задаём для этого глобальную переменную и при инициализации легко можем поникнуть это Окей либо если некорректные аргументыдля функции с которыми она вообще никак не работает Ну то есть мы знаем что система счисления меньше двойки не бывает и в данном случае поникнуть тоже приемлемо либо произошло недостижимое состояния например из буфера вычитали отрицательное количество символов поникнуть в этом случае тоже при Ну либо если команда в процессоре просто не реализована и финальное то что есть литеры которые нам позволяют всё это поддержать автоматически плюс-минус например следить за стайл гайдами защ есть линтер которыйзапрещает нам создавать не обрабатываемые ошибки и мы можем настроить тех местах где нужно врать и также отловить л Паники если это необходимо но стоит учитывать что только первые три нте есть в Гон lint C Вот теперь мы перейдём наверное к самой сути доклада но сразу стоит учитывать что любые рекомендации которые здесь даю они являются именно рекомендациями но никакой догмода просто имеете на готове для себя ответ почему вы это делаете И теперь давайте поговорим что мы хотим отшиб как это получить первоемы хотим понять что произошло где и когда потом воспроизвести уметь легко эту ситуацию Чтобы отловить отработать и решить эту проблему Ну и также дополнительно может быть накинуть другой функционал для нашей ошибки чтобы нам жилось легче и поговорим о том как понять что же произошло в нашей ошибке а в Гош ошибки тексто центри сам интерфейс нам об этом говорит что есть метод который возвращает строку Да мы можем попытаться создать отдельную переменную и с помощью неё описать А что у нас произошло но длинные названиедлинных переменных никто не любит да мы можем попытаться использовать комментарии он бесконечно длинный Но кто его будет обновлять плюс там нет динамических данных Да мы можем попытаться опять же использовать Custom накинуть туда динамических данных но надо понимать что конечным потребителем ошибки чаще всего является некоторый пользователь чик и ему важен текст а не Какой код внутри и поэтому лучше именно концентрироваться на тексте ошибки чтобы явно описать Что произошло у нас а плюс дополнительно так как у насошибка тексто центрина есть следующие интерфейсы которые позволяют нам разграничить разные вывод для ошибки через различные модификаторы виде рештки плюсы минуса и так далее плюс существует отдельный интерфейс который в случае е У нас очень сложно структурированная ошибка позволяет нам сформировать различный вывод для разных глаголов и модификаторов вывода Но пока он в экспериментальном варианте находится но всё равно его можно использовать и теперь давайте перейдём всё-таки какими же свойствами должен обладать Наш текстПервое это лаконичность и Выразительность на слайде вы видите пример ошибки А надо понимать что вряд ли кто-то из вас знает что значат эти коды либо имя и эта ошибка является лаконичной но не выразительной потому что мало кто сможет её понять с первого раза и Придётся делать дополнительный хоп чтобы понять А что это значит Поэтому такие ошибки стоит избегать именно текст Для ошибок А следующий вариант текста он уже выразительный но он достаточно длинный поэтому играя с этими метриками нужно приходить к тому чтобы текст был илаконичный и выразительный То есть можно было понять но при этом не супер длинно а следующее свойство которым должен обладать Наш текст и это уже гос специфичное свойство то что мы используем двоеточие для разделения разных кусочков сообщения и к этому просто стоит привыкнуть а дополнительно не Используйте слова которые не несут никакой информации То есть если мы в ошибке будем писать faor cannot это бессмысленно в большинстве случаев потому что ошибка уже говорит о том что пошло что-то не так и это можно удалить изошибки и ошибка станет короче и следующие последние два свойства начинаем с маленькой буквы наше сообщение Почему так потому что мы можем склеить несколько сообщений несколько ошибок либо несколько сообщений и если мы будем склеивать с большой буквой то у нас будет волна И это не очень приятно читать ну и в конце не ставим точку по той же самой причине потому что у нас уже есть двоеточия как разделитель Но если всё-таки хочется начинать сообщение влоги с большой буквы то это не проблема просто Добавляйте префикс сбольшой буквой в логирование но не в ошибке Теперь давайте поговорим как понять где и когда возникла ошибка и какой у нас есть инструментарий для этого первое чтобы понять что и где произошло нам нужно писать уникальный текст сечас на слайде вы видите два варианта ошибки по факту сху видим текст который отвечает на вопрос что произошло а снизу где произошло Поэтому не забывайте склеивать вместе его и такое сообщение оно довольно короткое и понятное но чаще всего мы будем применять их только в библиотеки потомучто библиотеки ограничены по функциональности Если же у нас библиотека либо приложение растёт и довольно большое то на каждом новом уровне функциональности мы добавляем дополнительный контекст который будет описывать какую функциональность прошла эта ошибка и таким образом мы будем понимать а где именно она произошла и какой путь проделала плюс дополнительным маркером который будет говорить что вы сделали хороший текст для ошибки то что вы можете Её легко найти через поиск в вашем редакторе либо черезгреб дополнительно надо понимать что у нас может текст ошибки от потребителя мы можем туда класть ещё больше данных и лучше пытаться сохранять тексто ошибки человека читаемым То есть можно было как будто можно было бы прочитать как обычный текст но а иногда например в приложениях если и либо в сервисных приложениях А у нас может быть очень длинный стек вызова и очень сложно сформировать какую-то человека понятную ошибку и в данном случае мы можем пренебречь читаемость и через двоеточие просто разделить эти участки такойвариант приемлем в библиотеках если она супер большая и на это нужно потратить много времени и окей использовать в сервисах но стоит избегать в comm интерфейсах потому что там конечный потребитель ошибки является пользователь а не программист который знает А что у нас там внутри происходит как же всего этого мы добиваемся мы добиваемся с помощью Error F Довольно простой инструмент и дополнительно можно ещё использовать а кастомные ошибки для того чтобы это докинути быстро получить эту информациюне тратя время на разработку и проработку текста ошибки есть э вариант когда мы добавляем а путь до файла и строчку кода а но такой вариант стоит применять только в сервисных приложениях потому что там ошибку Скорее всего будет читать разработчик а не пользователь это делается с помощью пинга мы создаём отдельную отдельный кастомный тип в который кладём путь и линию и потом финальном этот вранг и берём текущий Фрей и кладём в нашу ошибку следующее развитие этого способа - это использовать Я думаю многие пришлившку из других языков и привыкли к тому что крейс у нас есть всегда и возможно Если бы крейс у нас был в и остались в текущем мире они попали в мир будущего и на то были объективные причины первое если бы разработчики это сделали то мы потеряли бы обратную совместимость потому что перестало бы работать сравнение либо лек Deep equal следующим минусом то что произошло бы падение производительности для всех приложений и Это довольно весомый минус А следующий минус то что стектрейс по факту не информативен для рутин что яимею в виду Мы положили наш Трей в ошибку но мы видим только Трей текущий рутины а не родительской для этого нам нужно делать дополнительные действия чтобы этот Трей появился и тут возникает вопрос разработчиков типа А как это надо было сделать Это довольно нетривиальная задача поэтому и отказались от это дополнительная причина плюс непонятно что луше использовать и он даёт весь тек вызова нам сразу Трей же на каждом уровне где мы обрабатываем ошибку мы берём текущий стек фрейм где происходит ошибка и на каждом уровне этодоки это выглядит через Пинг примерно следующим образом и сейчас есть обсуждение Стоит ли добавлять стектрейс или Стоит ли добавить трейс именно в Гош Вы можете почитать в этих пропо залах а но как непонятно когда это будет заре вижена и будет ли а следующим минусом почему нету стектрейс скорее идеологический потому что стектрейс создаёт искусственное чувство осведомлённости стектрейс очень большой объём информации Но насколько эта информация качественна я бы сказал что он отвечает только на вопрос где произошла ошибка ноне отвечает на вопрос что произошло либо Как воспроизвести и многие разработчики когда делают ошибки они такие О я кину стектрейс супер У меня есть много информации но по факту два вопроса не отве и случае нам ВС равно нужно думать о тексте ошибки чтобы понять что произошло и думать о параметрах И именно поэтому Т не был применён из-за того что он позволяет лениться разработчику и не думать о ошибке и по факту отнимает возможность Что произошло понять что произошло и с какими параметрами это произошло ифинами треса в том что разные версии приложения у нас будут иметь разный стектрейс В случае когда у пользователя например версии V1 А у нас версия V2 и мы довольно сильно переписали код там где произошла ошибка к Trace просто не будет совпадать и будет бесполезен А если мы подумали над текстом то эта информация нам даст больше И если всё-таки вы решили что вам Т нужен это Например может быть полезно в случае когда у вас уже есть готовое приложение в котором не думали о тексте сообщения и вам нужно быстро получить информацию отом где произошла ошибка есть инструменты которые позволяют это сделать в автоматическом либо полуавтоматическом варианте чтобы добавить это в приложение ну и плюс можете прочитать как был реализован стектрейс предполагалась реализация стек рейса в гошкевич Почему всё-таки не Теперь давайте поговорим о том Как воспроизвести ошибки а для того чтобы воспроизводить ошибки нам нужно добавлять данные об этой ошибке в саму ошибку А самый простой способ - это наш любимый fmt rrf на каждом уровне мы просто докидополнительную информацию и это можно применять на в любых видах приложения а следующий вариант у нас может быть очень много параметров в нашей функции и мы можем попытаться записать их в одном из множества вариантов главное делайте это одинаково во всм приложении но основной минус когда мы так делаем так оформляем ошибку в том что если конечный пользователь потребитель ошибки не разработчик а пользователь то вряд ли он сможет нормально понять А что произошло Поэтому применяем только в сервисныхприложениях и очень редко в библиотеках следующий вариант как мы можем накинуть дополнительные дан в ошибку это C мы создаём отдельный тип прописываем те параметры которые хотим положить в ошибку и основной плюс в отличие то что мы можем программно обработать эти данные и сделать что-то с ними Например если у нас была ошибка от пользовательского конфига мы это прочитали поняли что формат пришёл от пользователя мы можем попытаться вызвать например дефолтные чтобы решить эту проблему следующий вариант как наполнитьэто сделать отдельный вранг который будет хранить неструктурированные данные А в него мы можем складывать всё что угодно но такой вариант О'кей только в сервисных приложениях потому что в библиотеках это не не универсальный способ и там нужно это будет как-то внедрять прописывать объяснять А в comm интерфейсах нам важно чтобы сообщение было понятным для для пользователя а если мы закинем туда кучу неструктурированных данных вряд ли ему будет легко разобраться и этот подход использует это вранг Мы также снизу вверх проходимдобавляем наши неструктурированные данные и где-то сверху вытаскиваем эти данные и спокойно их гиру А ещё в некоторых проектах я наблюдал когда люди делают логирование очень часто по месту возникновения ошибки и наверх прокиды Это плохой способ потому что по факту вы в лог можете накидать очень много ошибок и будет дублирование с которым придётся как-то работать чтобы этого можно просто на Нижнем уровне Когда вы влог скидывали все данные вместе с информацией из контекста просто положить эту информациюв ошибку и обработать где-то выше и такой вариант также Окей только для сервисных приложениях в случае если вы не думали о сообщении в ошибке и теперь давайте поговорим что у нас есть ещё для обработки ошибки из стандартных способов это заме простому сравнению и Switch также есть S который пришёл на замену ty и это два программных способа которые чаще всего стоит применять дополнительно есть STR Con и мы их используем только в том случае если работаем с ошибками старого кода которые не обрабатываемые иотливаем по средствам текста но понимаем что это супер ненад Ну и плюс можно себе синтаксический сахар в виде errors any Где мы можем сравнить ошибку с множеством ожидаемых И тем самым заменить eror is с множественным сравнением или а дополнительно хочу заметить что А мы чаще всего обрабатываем ошибки по месту там где они случились А небольшой значок дополнительной легенды который выглядит как значок на карте Он как раз будет это и обозначать выглядит обработка по месту довольно просто мы просто говорим If вместеполучения ошибки и дальше либо возвращаем либо возвращаемся пингом либо делаем что-то ещё такой способ обработки применим в любом виде приложения но у него есть недостаток что в случае если у нас например есть сервисное приложение в котором есть однотипная обработка ошибок то мы начинаем её дублировать чтобы этого избежать используем обработку обработку а значок в виде кружочка и стрелочки внутрь а чаще всего она выглядит в виде middleware либо декоратора и заключается в том что мы просто этот код который был у насразбросанно в одно место и таким образом создаём только одну точку Правды и облегчаем себе жизнь но применяем чаще всего его только в сервисных приложениях а далее А мы стараемся не игнорировать ошибки Почему так потому что в случае игнорирования мы просто можем стать слепыми котятами которые не понимают что происходит но даже если мы будем игнорировать то делайте пожалуйста Это явно через нижнее подчёркивание равно плюс дополнительно есть линтер который это отслеживают И вам говорит А где вы зали забыли обрабатывать ошибку но естьслучаи когда ой игнорировать ошибку когда ошибка возможно Например если мы маршам Jon из стандартной структуры какой-нибудь Там ошибка не может произойти есть линтер который это отлавливает и говорит нам что здесь Вы даже можете не обрабатывать Либо сама функция не внутри по коду не предполагает возврат ошибки Хотя в таком случае Можно наверное поникнуть потому что это Невозможная ситуация Но выбор за вами Ну либо если ошибка для вас не важна но всё-таки помечается такие места явно что вы понимаете что вы пропустили здесь ошибкуА следующий вариант обработки - это просто вернуть наверх ре можно применять в любом приложении как локально так и централизованно А следующий вариант - это дополнить текстом дополнить текстом можно через fmt F докинути пов А следующий вариант обработки ошибки - Это когда мы заменяем какую-то внутреннюю ошибку нашей ошибки один к одному такой вариант Окей для сервисных приложений и Ко интерфейса но может быть не приемлем для библиотек из-за того что мы не хотим терять нижележащие ошибки и хотимпонимать а что происходит дополнительно мы можем типизировать наши ошибки например обозначив что эта ошибка произошла в некоторое области которые относится к пользователю это можно сделать как с помою F так и создание кастомного типа далее мы можем объединять наши ошибки это может быть полезно когда одна ошибка повлекла за собо другую либо если мы обрабатываем например большой файл и хотим Сохранить все ошибки для каждой строчки этого файла в случае если же мы хотим сохранить нижележащие но мы также хотим пониматьпричину этого максимального количества и в этом случае нужно сохранять ниже лежащую ошибку плюс мы можем также просто обрабатывать ошибку с помощью трая повторяя действия но здесь пожалуйста Не забывайте про лимитирование по количеству и или времени й потому что иначе мы можем идти в бесконечный Цикл А это так себе плюс увеличиваем задержку по экспоненте чтобы не положить вызываемый сервис Ну и сохраняем ниже лежащую ошибку чтобы не лишать возможности понять разработчика а что конкретно произошло Почему мы достиглимаксимального количества и в библиотеке у которой есть аж 2.000 звёздочек э ошибка есть а вы будете не понимаете что происходит и у вас будет только ошибка Error Max rety поэтому а избегайте использования её А следующий вариант обработки - это логирование Довольно простой вариант можно использовать как по месту так и централизовано но а логирование в Common interf приложениях сомнительны потому что чаще всего мы просто возвращаем пользователю ошибку А в библиотеках он редко встречается плюс до того как у наспоявился S Log У нас не было какого-то универсального способа удобно логировать следующий вариант обработки - это graceful degradation его используем только в сервисах выглядит он довольно просто мы возвращаем значение по умолчанию и дополнительно производим какое-то действие виде логирования и А ещё один способ обработки А это recover чаще всего у них там кидаются паники и recover делать приемлемо именно для обработки ошибок а не для восстановления если мы не доверяем ниже лежащему коду А и хотим эниже лежащую панику обернуть в какую-то ошибку либо если у нас сервисное приложение и есть большое количество рутин и мы не хотим что в случае а падение одной грудины падало всё приложение например Когда у нас есть Много ручек в одной ручке одна ручка поникнуть в таком случае и финальном что обрабатываем ошибку мы только единожды То есть если А вы решили залоги то только пожалуйста логийко то только возвращаете либо врап её дополнительно но никогда ни оба этих действия потому что в ином случае Выбудете обрабатывать ошибку множество раз например множество раз её залоги ете или обозначите её как-то у себя И тем самым усложнить себе жизнь при решении этой ошибки выглядит обрабатывающим образом и мы не делаем этого и теперь ф Анализируя всё вышесказанное перейдём к регламентам из об мо что пишем лаконичный выразительный текст обрабатываем ошибку только один раз используем для определения ошибки и в случае если мы работаем со старым кодом который кидает нам не обрабатываем ошибки то тогда либои не панику для что касается библиотек библиотеках использу и для того чтобы получился уникальный текст предпочитаем использовать формат который понятен человеку то есть пользователю не знакомом с нашим по и в сложных случаях можно использовать формат с двоеточием когда мы разделяем каждый кусочек а дополнительно для того чтобы понять где и когда ошибка произошла мы используем только fmt Error F с глаголом w и свои собственные кастомные типы А для того чтобы воспроизводить также используем fmt с кастомными типами но все данныекоторые мы положили в ошибку мы должны их также положить и в текст для обработки чаще всего мы используем только обработку по месту спокойно возвращаем ошибку наверх либо врам её через добавление текста текущие операции либо место где произошла ошибка с аргументами что касается интерфейса здесь есть небольшое отличие что можно использовать не обрабатываемые ошибки потому что конечный потребитель ошибки является пользователь по тому как выглядит текст используем только человека читаемый текст потому что конечный пользовательпотребитель нашей ошибки - Это пользователь а всё остальное у нас остаётся без изменения относительно того чтобы понять где Когда произошла ошибка и как е воспроизводить ка обработки здесь мы можем иногда игнорировать ошибку но только явно если явно понимаем зачем мы это делаем и также можем заменять ошибку один к одному ниже лежащую на нами определённую ошибку и финальное сервисов здесь только используем senal eror кастомные ошибки и Вран для того чтобы как виды ошибок для того чтобы сформировать уникальный текст подходитоба варианта Как человекочитаемый так и через двоеточие чтобы не тратить на это супер много времени а плюс для того чтобы понять где и когда произошла ошибка мы можем использовать либо F Pass codeline вариант либо к Trace в случае если у нас код уже существует и он нам нужно быстро получить Понимание где и когда произошла ошибка но всё-таки стоит делать это не за счёт треса А за счёт текста а для того чтобы воспроизводить ошибку можем использовать как fmt с кастомными типами когда мы включаем в текст ошибки Эти параметры так и когдамы в Custom складываем в разы больше данных но не включаем их текст и пытаемся избегать в случае когда это возможно когда мы вытаскиваем все данные из контекста и кладём их в ошибку потому что там может быть лишняя информация которая по факту нам не супер нужна и просто нагружает разработчика в том чтобы понять А что именно там произошло и фи чтобы уметь обработать ошибку мы их можем обрабатывать как локально так и централизовано А тут дополнительно добавляется то что централизованно можем обрабатывать через Return eror либочерез Вран в моменте уже вывода пользователю плюс также централизованно начинаем обрабатывать й и логирование добавляется graceful degradation и можем Rec в случае когда мы не хотим чтобы нижележащие рутины разломали всё наше приложение и на этом всё лайки обратную связь пожалуйста кидайте по QR коду а также ссылка на презентацию есть ссылка на регламент текстом который я хотел попытаться закончить но сейчас он всё ещё в разработке и чат для обсуждения Если у вас есть какие-то вопросы либо Приходите лично Спасибо за внимание будурад вашим вопросам [аплодисменты] Илья Спасибо большое за доклад Есть ли вопросы в зале Если у вас есть вопрос пожалуйста высоко поднимите руку не задавайте вопрос с места к вам подойдут люди с микрофоном и вы сможете задать свой вопрос А теперь вопрос из зала Спасибо за доклад меня зовут Кирилл я из Яндекса У нас тоже большая боль с тем как ть ошибки потому что у нас по сути помойка где-то раться где-то в итоге дежурные Или разработчики страдают А как же всё-таки это сделать Вопрос такой ты упоминал что желательно не упоминатьстрочку кода и ну файл и номер строчки кода для того чтобы показать ошибку но из этого следует насколько я понимаю подтверди пожалуйста что текст ошибок должен быть уникальным чтобы разработчик мог найти и она будет одна единственно на все кодовой базе но такое такой вариант достаточно трудно поддерживать так ли это а Вполне себе ну то есть вариант когда мы пишем уникальный текст сразу довольно редок потому что го язык довольно молодой и все в него приходят из других языков Но это желаемый вариантИ как я уже сказал что да можно использовать как Т так и й Pass с колам в случае если у вас уже готовый проект и вы хотите быстро получить эти данные но в случае написания нового проекта всё-таки стоит думать о уникальном тексте и сразу это закладывать как упражнение во время написания текста Спасибо я Напоминаю что мы дарим уникальных редких матрёшек за лучшие вопросы вы можете создать и собрать себе Целую коллекцию А сейчас Давай перейдём к следующему вопросу Если что я подрабатываю твой секретарш и записываювопросы вопросы с той стороны зала Нет не всё Я всё правильно сказала это вопросы с той стороны зала Да привет Спасибо огромное за доклад такой вопрос я разработчик библиотеки у меня есть код который запускает грудины внутри которых что-то происходит и кидает время от времени ошибки Какая оптимальная стратегия обработки ошибок в таком случае вот у меня рутина крутится внутри библиотеки У пользователя есть НП что мне нужно добавить ещё чтобы пользователь мог адекватно среагировать на это всё так ещ раз Правильно ли я понял утебя есть рутины в библиотеке рути наверх выдают тебе ошибки и как тебе их обработать вопрос в том как их выдать наверх вот правильно то есть они существуют внутри как их туда передать А ну смотри у тебя есть разные варианты есть GR который позволяет с этим работать также Ты можешь кинуть через каналы плюс у тебя может быть вообще вариант Когда тебе много рутин но тебе нужен ответ только от одной и это другой вариант обработки ошибки и если попытаться суммировать то самый простой способ в моей головеэто Но если у тебя какой-то Более сложный вариант ты используешь каналы для выдачи ошибок наверх дополнительно можно в каналы же записывать составную составное составной результат где у тебя например часть ошибки - это результат точнее часть ответа - это результат а часть ошибки спасибо спасибо следующий вопрос за 2Т раз Привет Илья Спасибо за доклад реально систематизировано и можно взять и в работу пустить сразу же вопросик такой вот в принципе основная методология это такая идёт запрос и когда Ну как у тебя описано примерновозникает ошибка мы её примеру Загирова и дальше возвращаем с рангом там по не там да так как шли вызовы вот для простого для простого сервиса запрос ответ где оно там было достаточно просто А вот допустим когда я столкнулся скажем так с разработкой сложных приложений то применяли противоположную немного философию То есть у нас с запросом к примеру шёл всегда логгер прокиды логгер шёл и он как бы каждый раз ви метод там и виз ещё какая-то контекстной информации и он доходил к примеру до места где всёпадало и мы из этого этот логе сразу же мог логировать и показывать вообще всю эту историю Да в этом месте и из этого логе мы же делали То есть у него был метод который просто мог сразу же вернуть вот этот путь и возвращать ошибку можно было не делая дальше виз Ну не делая на обратном возвращении ошибки вот этот вот скажем вранг То есть как бы всё своё ношу с собой логгер так шёл и он как бы в нём сразу всё было Вот сталкивался нет С такой с таким подходом А если сталкивался там какие грабелькибыли или там Я скорее уже сразу Обозначил на не помню На каком слайде что это не Сай лучший вариант то есть по факту вы делаете двойную обработку вы логи ете и пробрасывается ошибку наверх я сталкивался с таким когда мы набирали весь контекст чтобы понимать а что происходит потому что система была супер непонятная но в таком случае мы старались применить уйти от этого варианта и сделать примерно следующим образом что мы там где произошла ошибка вытаскиваем все данные из контекста и потом выкидываем наверх вместе с ошибкой И ужеобрабатываем месте потому что как мы не пытались у нас всё равно проходи происходило Так что мы логи одно и то же сообщение несколько раз и приходилось его рассчитывать Поня пытаться понять А это множество ошибок или это одна ошибка и лучше сделать так чтобы обработала с ошибка только один раз И для этого есть как раз инструмент что мы можем вытащить всё что нужно из контекста положить в ошибку и отправить наверх и уже где-то сверху обработать супер спасибо У нас есть вопросы с чата зала где размещатьобъявление Custom eror в проекте а отличный вопрос Там где по функциональности и происходит ошибка То есть это в случае написания библиотек но если например вы хотите делать какой-то универсальный вранг для сервисных приложений как например вот этот Data Вран то Вполне себе можно это вынести как отдельную библиотечку и разместить там и сделать её общей как для вашего одного проекта так и потом размножить этот подход везде супер спасибо если ещё вопросы в зале поднимите пожалуйста руку мы к вам подойдём с микрофоном пожалуйста держитемикрофон у рта Говорите в него потому что иначе вас не будет просто слышно Добрый день Андрей из утех такой вопрос У вас не возникали ситуации когда задача воспроизведения ошибки вступает в конфликт с задачей не засветить персональные данные а тут задача такая Возникала Но это довольно Широкая тема в которую можно прямо очень глубоко погружаться самый простой вариант - это просто заменить один текст где есть персональные данные на либо какие-то Sens данные это могут быть не только персональные данныенапример что какая-то Ошибка от базы данных которую мы не хотим показать конечному пользователю просто заменой либо есть варианты когда мы в форматирование добавляем дополнительное условно тегирование наших данных чтобы они не вылезли наверх а напишите я вам скину прямо пример у короч db есть неплохая реализация У спасибо спасибо Есть ли ещё вопросы в зале а с правой стороны зала Вопрос Раз раз слышно э у нас у нас следующая проблемка сейчас что у нас есть условно э наборные такие так называемые ошибки напримертипа есть у нас огромный config life cycle в S3 у которого на самом деле очень много всяких комбинаций того как поля друг с другом могут состыковаться и не состыковаться и кажется что стратегия когда мы идём вот этот конфиг парсим и проверяем его динамически валидатора и доки дым туда вот условно просто конкатенации через двоеточие новые теги по поводу ошибок э выплёвывает нам на выходе какую-то совершенно невменяемая пользователю и библиотеки нашей вообще ничего не скажет что вообще можно с таким вот подходом сделать А спасибо чтоя вижу можно попытаться создать кастомный Тип который будет описывать условно Что за поле А в котором произошла ошибка плюс описать А что это за ошибка именно в контексте вашего парсинга и потом сжо инить множество этих ошибок например туда Также можно Дописать линию файла где произошла и таким образом уже вы сможете имея все эти данные сформировать нужное сообщение вашему пользователю супер спасибо У нас есть ещё время примерно на два вопроса из зала Не забывайте о том что даже если вы не успели задать свой вопрос в заледальше мы с докладчиком отправимся в дискуссионную зону в которой можно будет продолжить разговор и уже лично пообщаться с докладчиком А сейчас вопрос С левой полови зала Привет с У меня вопрос такой а можно ли агрегировать Ну и группировать ошибки То есть например выдавать ошибку только в том случае если их набралось там не знаю 10 одинаковых и ну и только в этом случае её как бы пулять как в таких случаях действовать Вот а если нет то просто игнорировать А так ты имеешь в виду в случае если больше дети Мы делаем ошибку Если меньшедесяти то мы просто игнорируем ну нам никто это не мешает у на ошибка - это значение и по факту мы Ну массив ошибок и проверить это условие и потом в случае если больше о кидаем Если меньше игнорирую всё Поня Спасибо и последний вопрос из зала вот на первом ряду спасибо очень поучительно вопрос про по мотивам слайда где оборачиваются HT ошибки прямо видно что это ного занять А есть ли какой-то универсальный подход потому что и в лих и в сервисах достаточно стандартная ситуация когда нужно наружу отдаватьуникальные коды ошибок регламентированные документированные универсальный подход для этой задачи ну вполне себе чаще всего мы делаем такого рода midle Если мы используем стандартные вариант обработки ошибок А в случае большинства фреймворков там эти встроены и используем просто решения А если Нужна статья с более подробным описанием как это делать приходи ко мне я тебе скину супер это можно ещё поподробнее будет обсудить собственно в дискуссионной зоне там же забрать твои контакты например А давай выберем вопрос который тебе большевсего понравился а а что у нас было что у нас настоя так Ну давай я перечислю благо я секретарша сегодня а не упоминать строчку текста если текст уникален как это поддерживать вопрос про рутины которые задавал Дима подход когда логгер внутри нужно пробрасывается тот вопрос про то как понять ошибка уникальна или нет отлично Пожалуйста поднимите руку человек который задавал этот вопрос высоко было видно и вас нашли хелперы не стесняюсь поднимать руки Я не понимаю в чём проблема а Спасибо вам большое Неуходите пожалуйста из зала вас Мы тоже Хотим поблагодарить Спасибо большое что пришли рассказать доклад Тем более что это не первый доклад который я слышу у тебя и мне каждый раз нравится это вам Приходи приходи рассказывать нам ещё с вами я сейчас